{"version":3,"file":"index.js","sources":["../../../../packages/php-wasm/util/src/lib/php-vars.ts","../../../../packages/playground/common/src/create-memoized-fetch.ts","../../../../packages/playground/common/src/index.ts"],"sourcesContent":["export function phpVar(value: unknown): string {\n\treturn `json_decode(base64_decode('${stringToBase64(\n\t\tJSON.stringify(value)\n\t)}'), true)`;\n}\n\nexport function phpVars<T extends Record<string, unknown>>(\n\tvars: T\n): Record<keyof T, string> {\n\tconst result: Record<string, string> = {};\n\tfor (const key in vars) {\n\t\tresult[key] = phpVar(vars[key]);\n\t}\n\treturn result as Record<keyof T, string>;\n}\n\nfunction stringToBase64(str: string) {\n\treturn bytesToBase64(new TextEncoder().encode(str));\n}\n\nfunction bytesToBase64(bytes: Uint8Array) {\n\tconst binString = String.fromCodePoint(...bytes);\n\treturn btoa(binString);\n}\n","export interface CachedFetchResponse {\n\tbody: ReadableStream<Uint8Array>;\n\tresponseInit: ResponseInit;\n}\n\n/**\n * Creates a fetch function that memoizes the response stream.\n * Calling it twice will return a response with the same status,\n * headers, and the body stream.\n * Memoization is keyed by URL. Method, headers etc are ignored.\n *\n * @param originalFetch The fetch function to memoize. Defaults to the global fetch.\n */\nexport function createMemoizedFetch(originalFetch = fetch) {\n\tconst cache: Record<\n\t\tstring,\n\t\tPromise<CachedFetchResponse> | CachedFetchResponse\n\t> = {};\n\n\treturn async function memoizedFetch(url: string, options?: RequestInit) {\n\t\tif (!cache[url]) {\n\t\t\t// Write to cache synchronously to avoid duplicate requests.\n\t\t\tcache[url] = originalFetch(url, options).then((response) => ({\n\t\t\t\tbody: response.body!,\n\t\t\t\tresponseInit: {\n\t\t\t\t\tstatus: response.status,\n\t\t\t\t\tstatusText: response.statusText,\n\t\t\t\t\theaders: response.headers,\n\t\t\t\t},\n\t\t\t}));\n\t\t}\n\t\tconst { body, responseInit } = await cache[url];\n\t\t// Split the response stream so that the cached one is not consumed.\n\t\tconst [left, right] = body.tee();\n\t\t// Cache the \"left\" stream and don't use it until the next .tee().\n\t\tcache[url] = {\n\t\t\tbody: left,\n\t\t\tresponseInit,\n\t\t};\n\t\t// Return the \"right\" stream for consumption.\n\t\treturn new Response(right, responseInit);\n\t};\n}\n","/**\n * Avoid adding new code here. @wp-playground/common should remain\n * as lean as possible.\n *\n * This package exists to avoid circular dependencies. Let's not\n * use it as a default place to add code that doesn't seem to fit\n * anywhere else. If there's no good place for your code, perhaps\n * it needs to be restructured? Or maybe there's a need for a new package?\n * Let's always consider these questions before adding new code here.\n */\n\nimport { UniversalPHP } from '@php-wasm/universal';\nimport { phpVars } from '@php-wasm/util';\n\nexport { createMemoizedFetch } from './create-memoized-fetch';\n\nexport const RecommendedPHPVersion = '8.0';\n\n/**\n * Unzip a zip file inside Playground.\n */\nconst tmpPath = '/tmp/file.zip';\nexport const unzipFile = async (\n\tphp: UniversalPHP,\n\tzipPath: string | File,\n\textractToPath: string,\n\toverwriteFiles = true\n) => {\n\tif (zipPath instanceof File) {\n\t\tconst zipFile = zipPath;\n\t\tzipPath = tmpPath;\n\t\tawait php.writeFile(\n\t\t\tzipPath,\n\t\t\tnew Uint8Array(await zipFile.arrayBuffer())\n\t\t);\n\t}\n\tconst js = phpVars({\n\t\tzipPath,\n\t\textractToPath,\n\t\toverwriteFiles,\n\t});\n\tawait php.run({\n\t\tcode: `<?php\n        function unzip($zipPath, $extractTo, $overwriteFiles = true)\n        {\n            if (!is_dir($extractTo)) {\n                mkdir($extractTo, 0777, true);\n            }\n            $zip = new ZipArchive;\n            $res = $zip->open($zipPath);\n            if ($res === TRUE) {\n\t\t\t\tfor ($i = 0; $i < $zip->numFiles; $i++) {\n\t\t\t\t\t$filename = $zip->getNameIndex($i);\n\t\t\t\t\t$fileinfo = pathinfo($filename);\n\t\t\t\t\t$extractFilePath = rtrim($extractTo, '/') . '/' . $filename;\n\t\t\t\t\t// Check if file exists and $overwriteFiles is false\n\t\t\t\t\tif (!file_exists($extractFilePath) || $overwriteFiles) {\n\t\t\t\t\t\t// Extract file\n\t\t\t\t\t\t$zip->extractTo($extractTo, $filename);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$zip->close();\n\t\t\t\tchmod($extractTo, 0777);\n            } else {\n                throw new Exception(\"Could not unzip file: \" . $zip->getStatusString());\n            }\n        }\n        unzip(${js.zipPath}, ${js.extractToPath}, ${js.overwriteFiles});\n        `,\n\t});\n\tif (await php.fileExists(tmpPath)) {\n\t\tawait php.unlink(tmpPath);\n\t}\n};\n\nexport const zipDirectory = async (\n\tphp: UniversalPHP,\n\tdirectoryPath: string\n) => {\n\tconst outputPath = `/tmp/file${Math.random()}.zip`;\n\tconst js = phpVars({\n\t\tdirectoryPath,\n\t\toutputPath,\n\t});\n\tawait php.run({\n\t\tcode: `<?php\n\t\tfunction zipDirectory($directoryPath, $outputPath) {\n\t\t\t$zip = new ZipArchive;\n\t\t\t$res = $zip->open($outputPath, ZipArchive::CREATE);\n\t\t\tif ($res !== TRUE) {\n\t\t\t\tthrow new Exception('Failed to create ZIP');\n\t\t\t}\n\t\t\t$files = new RecursiveIteratorIterator(\n\t\t\t\tnew RecursiveDirectoryIterator($directoryPath)\n\t\t\t);\n\t\t\tforeach ($files as $file) {\n\t\t\t\t$file = strval($file);\n\t\t\t\tif (is_dir($file)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t$zip->addFile($file, substr($file, strlen($directoryPath)));\n\t\t\t}\n\t\t\t$zip->close();\n\t\t\tchmod($outputPath, 0777);\n\t\t}\n\t\tzipDirectory(${js.directoryPath}, ${js.outputPath});\n\t\t`,\n\t});\n\n\tconst fileBuffer = await php.readFileAsBuffer(outputPath);\n\tphp.unlink(outputPath);\n\treturn fileBuffer;\n};\n"],"names":["phpVar","value","stringToBase64","phpVars","vars","result","key","str","bytesToBase64","bytes","binString","createMemoizedFetch","originalFetch","cache","url","options","response","body","responseInit","left","right","RecommendedPHPVersion","tmpPath","unzipFile","php","zipPath","extractToPath","overwriteFiles","zipFile","js","zipDirectory","directoryPath","outputPath","fileBuffer"],"mappings":"AAAO,SAASA,EAAOC,EAAwB,CAC9C,MAAO,8BAA8BC,EACpC,KAAK,UAAUD,CAAK,CACpB,CAAA,WACF,CAEO,SAASE,EACfC,EAC0B,CAC1B,MAAMC,EAAiC,CAAA,EACvC,UAAWC,KAAOF,EACjBC,EAAOC,CAAG,EAAIN,EAAOI,EAAKE,CAAG,CAAC,EAExB,OAAAD,CACR,CAEA,SAASH,EAAeK,EAAa,CACpC,OAAOC,EAAc,IAAI,YAAA,EAAc,OAAOD,CAAG,CAAC,CACnD,CAEA,SAASC,EAAcC,EAAmB,CACzC,MAAMC,EAAY,OAAO,cAAc,GAAGD,CAAK,EAC/C,OAAO,KAAKC,CAAS,CACtB,CCVgB,SAAAC,EAAoBC,EAAgB,MAAO,CAC1D,MAAMC,EAGF,CAAA,EAEG,OAAA,eAA6BC,EAAaC,EAAuB,CAClEF,EAAMC,CAAG,IAEPD,EAAAC,CAAG,EAAIF,EAAcE,EAAKC,CAAO,EAAE,KAAMC,IAAc,CAC5D,KAAMA,EAAS,KACf,aAAc,CACb,OAAQA,EAAS,OACjB,WAAYA,EAAS,WACrB,QAASA,EAAS,OACnB,CACC,EAAA,GAEH,KAAM,CAAE,KAAAC,EAAM,aAAAC,CAAA,EAAiB,MAAML,EAAMC,CAAG,EAExC,CAACK,EAAMC,CAAK,EAAIH,EAAK,IAAI,EAE/B,OAAAJ,EAAMC,CAAG,EAAI,CACZ,KAAMK,EACN,aAAAD,CAAA,EAGM,IAAI,SAASE,EAAOF,CAAY,CAAA,CAEzC,CC1BO,MAAMG,EAAwB,MAK/BC,EAAU,gBACHC,EAAY,MACxBC,EACAC,EACAC,EACAC,EAAiB,KACb,CACJ,GAAIF,aAAmB,KAAM,CAC5B,MAAMG,EAAUH,EACNA,EAAAH,EACV,MAAME,EAAI,UACTC,EACA,IAAI,WAAW,MAAMG,EAAQ,aAAa,CAAA,CAE5C,CACA,MAAMC,EAAK1B,EAAQ,CAClB,QAAAsB,EACA,cAAAC,EACA,eAAAC,CAAA,CACA,EACD,MAAMH,EAAI,IAAI,CACb,KAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAyBQK,EAAG,OAAO,KAAKA,EAAG,aAAa,KAAKA,EAAG,cAAc;AAAA,SAAA,CAEnE,EACG,MAAML,EAAI,WAAWF,CAAO,GACzB,MAAAE,EAAI,OAAOF,CAAO,CAE1B,EAEaQ,EAAe,MAC3BN,EACAO,IACI,CACJ,MAAMC,EAAa,YAAY,KAAK,OAAA,CAAQ,OACtCH,EAAK1B,EAAQ,CAClB,cAAA4B,EACA,WAAAC,CAAA,CACA,EACD,MAAMR,EAAI,IAAI,CACb,KAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBAoBSK,EAAG,aAAa,KAAKA,EAAG,UAAU;AAAA,GAAA,CAEjD,EAED,MAAMI,EAAa,MAAMT,EAAI,iBAAiBQ,CAAU,EACxD,OAAAR,EAAI,OAAOQ,CAAU,EACdC,CACR"}