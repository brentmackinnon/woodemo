function l(e){return`json_decode(base64_decode('${d(JSON.stringify(e))}'), true)`}function $(e){const t={};for(const r in e)t[r]=l(e[r]);return t}function d(e){return p(new TextEncoder().encode(e))}function p(e){const t=String.fromCodePoint(...e);return btoa(t)}function h(e=fetch){const t={};return async function(i,n){t[i]||(t[i]=e(i,n).then(o=>({body:o.body,responseInit:{status:o.status,statusText:o.statusText,headers:o.headers}})));const{body:a,responseInit:s}=await t[i],[f,u]=a.tee();return t[i]={body:f,responseInit:s},new Response(u,s)}}const w="8.0",c="/tmp/file.zip",z=async(e,t,r,i=!0)=>{if(t instanceof File){const a=t;t=c,await e.writeFile(t,new Uint8Array(await a.arrayBuffer()))}const n=$({zipPath:t,extractToPath:r,overwriteFiles:i});await e.run({code:`<?php
        function unzip($zipPath, $extractTo, $overwriteFiles = true)
        {
            if (!is_dir($extractTo)) {
                mkdir($extractTo, 0777, true);
            }
            $zip = new ZipArchive;
            $res = $zip->open($zipPath);
            if ($res === TRUE) {
				for ($i = 0; $i < $zip->numFiles; $i++) {
					$filename = $zip->getNameIndex($i);
					$fileinfo = pathinfo($filename);
					$extractFilePath = rtrim($extractTo, '/') . '/' . $filename;
					// Check if file exists and $overwriteFiles is false
					if (!file_exists($extractFilePath) || $overwriteFiles) {
						// Extract file
						$zip->extractTo($extractTo, $filename);
					}
				}
				$zip->close();
				chmod($extractTo, 0777);
            } else {
                throw new Exception("Could not unzip file: " . $zip->getStatusString());
            }
        }
        unzip(${n.zipPath}, ${n.extractToPath}, ${n.overwriteFiles});
        `}),await e.fileExists(c)&&await e.unlink(c)},x=async(e,t)=>{const r=`/tmp/file${Math.random()}.zip`,i=$({directoryPath:t,outputPath:r});await e.run({code:`<?php
		function zipDirectory($directoryPath, $outputPath) {
			$zip = new ZipArchive;
			$res = $zip->open($outputPath, ZipArchive::CREATE);
			if ($res !== TRUE) {
				throw new Exception('Failed to create ZIP');
			}
			$files = new RecursiveIteratorIterator(
				new RecursiveDirectoryIterator($directoryPath)
			);
			foreach ($files as $file) {
				$file = strval($file);
				if (is_dir($file)) {
					continue;
				}
				$zip->addFile($file, substr($file, strlen($directoryPath)));
			}
			$zip->close();
			chmod($outputPath, 0777);
		}
		zipDirectory(${i.directoryPath}, ${i.outputPath});
		`});const n=await e.readFileAsBuffer(r);return e.unlink(r),n};export{w as RecommendedPHPVersion,h as createMemoizedFetch,z as unzipFile,x as zipDirectory};
//# sourceMappingURL=index.js.map
