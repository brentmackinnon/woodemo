const f = function() {
  var n;
  return typeof process < "u" && ((n = process.release) == null ? void 0 : n.name) === "node" ? "NODE" : typeof window < "u" ? "WEB" : (
    // @ts-ignore
    typeof WorkerGlobalScope < "u" && // @ts-ignore
    self instanceof WorkerGlobalScope ? "WORKER" : "NODE"
  );
}();
if (f === "NODE") {
  let n = function(e) {
    return new Promise(function(t, r) {
      e.onload = e.onerror = function(i) {
        e.onload = e.onerror = null, i.type === "load" ? t(e.result) : r(new Error("Failed to read the blob/file"));
      };
    });
  }, a = function() {
    const e = new Uint8Array([1, 2, 3, 4]), r = new File([e], "test").stream();
    try {
      return r.getReader({ mode: "byob" }), !0;
    } catch {
      return !1;
    }
  };
  if (typeof File > "u") {
    class e extends Blob {
      constructor(r, i, s) {
        super(r);
        let o;
        s != null && s.lastModified && (o = /* @__PURE__ */ new Date()), (!o || isNaN(o.getFullYear())) && (o = /* @__PURE__ */ new Date()), this.lastModifiedDate = o, this.lastModified = o.getMilliseconds(), this.name = i || "";
      }
    }
    global.File = e;
  }
  typeof Blob.prototype.arrayBuffer > "u" && (Blob.prototype.arrayBuffer = function() {
    const t = new FileReader();
    return t.readAsArrayBuffer(this), n(t);
  }), typeof Blob.prototype.text > "u" && (Blob.prototype.text = function() {
    const t = new FileReader();
    return t.readAsText(this), n(t);
  }), (typeof Blob.prototype.stream > "u" || !a()) && (Blob.prototype.stream = function() {
    let e = 0;
    const t = this;
    return new ReadableStream({
      type: "bytes",
      // 0.5 MB seems like a reasonable chunk size, let's adjust
      // this if needed.
      autoAllocateChunkSize: 512 * 1024,
      async pull(r) {
        const i = r.byobRequest.view, o = await t.slice(
          e,
          e + i.byteLength
        ).arrayBuffer(), u = new Uint8Array(o);
        new Uint8Array(i.buffer).set(u);
        const l = u.byteLength;
        r.byobRequest.respond(l), e += l, e >= t.size && r.close();
      }
    });
  });
}
if (f === "NODE" && typeof CustomEvent > "u") {
  class n extends Event {
    constructor(e, t = {}) {
      super(e, t), this.detail = t.detail;
    }
    initCustomEvent() {
    }
  }
  globalThis.CustomEvent = n;
}
f === "NODE" && typeof URL.canParse != "function" && (globalThis.URL.canParse = function(n) {
  try {
    return !!new URL(n);
  } catch {
    return !1;
  }
});
//# sourceMappingURL=index.js.map
