import { isURLScoped as l, setURLScope as h, getURLScope as i } from "@php-wasm/scopes";
const p = 25e3;
let f = 0;
function g(e, t, ...o) {
  const n = d();
  return e.postMessage(
    {
      ...t,
      requestId: n
    },
    ...o
  ), n;
}
function d() {
  return ++f;
}
function m(e, t, o = p) {
  return new Promise((n, c) => {
    const r = (a) => {
      a.data.type === "response" && a.data.requestId === t && (e.removeEventListener("message", r), clearTimeout(s), n(a.data.response));
    }, s = setTimeout(() => {
      c(new Error("Request timed out")), e.removeEventListener("message", r);
    }, o);
    e.addEventListener("message", r);
  });
}
function w(e, t) {
  return {
    type: "response",
    requestId: e,
    response: t
  };
}
async function E(e) {
  let t = new URL(e.request.url);
  if (!l(t))
    try {
      const s = new URL(e.request.referrer);
      t = h(t, i(s));
    } catch {
    }
  const o = e.request.headers.get("content-type"), n = e.request.method === "POST" ? new Uint8Array(await e.request.clone().arrayBuffer()) : void 0, c = {};
  for (const s of e.request.headers.entries())
    c[s[0]] = s[1];
  let r;
  try {
    const s = {
      method: "request",
      args: [
        {
          body: n,
          url: t.toString(),
          method: e.request.method,
          headers: {
            ...c,
            Host: t.host,
            // Safari and Firefox don't make the User-Agent header
            // available in the fetch event. Let's add it manually:
            "User-agent": self.navigator.userAgent,
            "Content-type": o
          }
        }
      ]
    }, a = i(t);
    if (a === null)
      throw new Error(
        `The URL ${t.toString()} is not scoped. This should not happen.`
      );
    const u = await y(s, a);
    r = await m(self, u), delete r.headers["x-frame-options"];
  } catch (s) {
    throw console.error(s, { url: t.toString() }), s;
  }
  return r.httpStatusCode >= 300 && r.httpStatusCode <= 399 && r.headers.location ? Response.redirect(
    r.headers.location[0],
    r.httpStatusCode
  ) : new Response(r.bytes, {
    headers: r.headers,
    status: r.httpStatusCode
  });
}
async function y(e, t) {
  const o = d();
  for (const n of await self.clients.matchAll({
    // Sometimes the client that triggered the current fetch()
    // event is considered uncontrolled in Google Chrome. This
    // only happens on the first few fetches() after the initial
    // registration of the service worker.
    includeUncontrolled: !0
  }))
    n.postMessage({
      ...e,
      /**
       * Attach the scope with a URL starting with `/scope:` to this message.
       *
       * We need this mechanics because this worker broadcasts
       * events to all the listeners across all browser tabs. Scopes
       * helps WASM workers ignore requests meant for other WASM workers.
       */
      scope: t,
      requestId: o
    });
  return o;
}
async function S(e, t) {
  const o = ["GET", "HEAD"].includes(e.method) || "body" in t ? void 0 : await e.blob();
  return new Request(t.url || e.url, {
    body: o,
    method: e.method,
    headers: e.headers,
    referrer: e.referrer,
    referrerPolicy: e.referrerPolicy,
    mode: e.mode === "navigate" ? "same-origin" : e.mode,
    credentials: e.credentials,
    cache: e.cache,
    redirect: e.redirect,
    integrity: e.integrity,
    ...t
  });
}
function U(e) {
  const t = {};
  return e.headers.forEach((o, n) => {
    t[n] = o;
  }), t;
}
export {
  m as awaitReply,
  y as broadcastMessageExpectReply,
  S as cloneRequest,
  E as convertFetchEventToPHPRequest,
  d as getNextRequestId,
  U as getRequestHeaders,
  g as postMessageExpectReply,
  w as responseTo
};
