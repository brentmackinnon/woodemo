import { GeneratedCertificate } from './tls/certificates';
export type TCPOverFetchOptions = {
    CAroot: GeneratedCertificate;
    corsProxyUrl?: string;
};
/**
 * Sets up a WebSocket that analyzes the received bytes and, if they look like
 * TLS or HTTP, handles the network transmission using fetch().
 */
export declare const tcpOverFetchWebsocket: (tcpOptions: TCPOverFetchOptions) => {
    websocket: {
        url: (_: any, host: string, port: string) => string;
        subprotocol: string;
        decorator: () => {
            new (url: string, wsOptions: string[]): {
                CONNECTING: number;
                OPEN: number;
                CLOSING: number;
                CLOSED: number;
                readyState: number;
                binaryType: string;
                bufferedAmount: number;
                extensions: string;
                protocol: string;
                host: string;
                port: number;
                listeners: Map<string, any>;
                CAroot?: GeneratedCertificate | undefined;
                corsProxyUrl?: string | undefined;
                clientUpstream: TransformStream<any, any>;
                clientUpstreamWriter: WritableStreamDefaultWriter<any>;
                clientDownstream: TransformStream<any, any>;
                fetchInitiated: boolean;
                bufferedBytesFromClient: Uint8Array;
                url: string;
                options: string[];
                on(eventName: string, callback: (e: any) => void): void;
                once(eventName: string, callback: (e: any) => void): void;
                addEventListener(eventName: string, callback: (e: any) => void): void;
                removeListener(eventName: string, callback: (e: any) => void): void;
                removeEventListener(eventName: string, callback: (e: any) => void): void;
                emit(eventName: string, data?: any): void;
                onclose(data: any): void;
                onerror(data: any): void;
                onmessage(data: any): void;
                onopen(data: any): void;
                /**
                 * Emscripten calls this method whenever the WASM module
                 * writes bytes to the TCP socket.
                 */
                send(data: ArrayBuffer): void;
                fetchOverTLS(): Promise<void>;
                fetchOverHTTP(): Promise<void>;
                close(): void;
            };
        };
    };
};
export interface TCPOverFetchWebsocketOptions {
    CAroot?: GeneratedCertificate;
    /**
     * If true, the WebSocket will emit 'message' events with the received bytes
     * and the 'close' event when the WebSocket is closed.
     *
     * If false, the consumer will be responsible for reading the bytes from the
     * clientDownstream stream and tracking the closure of that stream.
     */
    outputType?: 'messages' | 'stream';
    corsProxyUrl?: string;
}
export declare class TCPOverFetchWebsocket {
    url: string;
    options: string[];
    CONNECTING: number;
    OPEN: number;
    CLOSING: number;
    CLOSED: number;
    readyState: number;
    binaryType: string;
    bufferedAmount: number;
    extensions: string;
    protocol: string;
    host: string;
    port: number;
    listeners: Map<string, any>;
    CAroot?: GeneratedCertificate;
    corsProxyUrl?: string;
    clientUpstream: TransformStream<any, any>;
    clientUpstreamWriter: WritableStreamDefaultWriter<any>;
    clientDownstream: TransformStream<any, any>;
    fetchInitiated: boolean;
    bufferedBytesFromClient: Uint8Array;
    constructor(url: string, options: string[], { CAroot, corsProxyUrl, outputType, }?: TCPOverFetchWebsocketOptions);
    on(eventName: string, callback: (e: any) => void): void;
    once(eventName: string, callback: (e: any) => void): void;
    addEventListener(eventName: string, callback: (e: any) => void): void;
    removeListener(eventName: string, callback: (e: any) => void): void;
    removeEventListener(eventName: string, callback: (e: any) => void): void;
    emit(eventName: string, data?: any): void;
    onclose(data: any): void;
    onerror(data: any): void;
    onmessage(data: any): void;
    onopen(data: any): void;
    /**
     * Emscripten calls this method whenever the WASM module
     * writes bytes to the TCP socket.
     */
    send(data: ArrayBuffer): void;
    fetchOverTLS(): Promise<void>;
    fetchOverHTTP(): Promise<void>;
    close(): void;
}
